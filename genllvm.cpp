//this source code was generated by @chatgpt it could have bugs and errors
//for now it's just a proof of concept to show how to generate LLVM IR from chibicc
//it's under development and not ready for production


#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/Verifier.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/Type.h>
#include <llvm/Support/TargetSelect.h>
#include <llvm/Support/raw_ostream.h>
#include <llvm/Target/TargetMachine.h>
#include <llvm/Support/FileSystem.h>
#include <llvm/TargetParser/Host.h>
#include <llvm/Support/raw_ostream.h>
#include <llvm/IR/LegacyPassManager.h>
#include <llvm/Support/CommandLine.h>
#include <vector>
#include <cstdio>

// Include chibicc headers
extern "C" {
#include "chibicc.h" // Adjust this include to the correct path where chibicc types are defined
}

using namespace llvm;


llvm::Type* convertType(llvm::LLVMContext &context, chibiccType *ty) {
    if (!ty) return nullptr;  // Handle null pointer

    switch (ty->kind) {
        case TY_VOID:
            return llvm::Type::getVoidTy(context);
        case TY_BOOL:
            return llvm::Type::getInt1Ty(context);
        case TY_CHAR:
            return llvm::Type::getInt8Ty(context);
        case TY_SHORT:
            return llvm::Type::getInt16Ty(context);
        case TY_INT:
            return llvm::Type::getInt32Ty(context);
        case TY_LONG:
            return llvm::Type::getInt64Ty(context);
        case TY_FLOAT:
            return llvm::Type::getFloatTy(context);
        case TY_DOUBLE:
            return llvm::Type::getDoubleTy(context);
        case TY_LDOUBLE:
            return llvm::Type::getFP128Ty(context);
        case TY_ENUM:
            return llvm::Type::getInt32Ty(context);
        case TY_PTR:
            return llvm::Type::getInt8PtrTy(context);
        case TY_FUNC: {
            std::vector<llvm::Type*> paramTypes;
            for (chibiccType *paramTy = ty->params; paramTy; paramTy = paramTy->next) {
                llvm::Type *paramType = convertType(context, paramTy);
                if (!paramType) {
                    llvm::errs() << "Error: Invalid parameter type.\n";
                    return nullptr;
                }
                paramTypes.push_back(paramType);
            }
            llvm::Type *returnType = convertType(context, ty->return_ty);
            if (!returnType) {
                llvm::errs() << "Error: Invalid return type.\n";
                return nullptr;
            }
            return llvm::FunctionType::get(returnType, paramTypes, ty->is_variadic);
        }
        case TY_ARRAY:
            return llvm::ArrayType::get(convertType(context, ty->base), ty->array_len);
        case TY_VLA:
            llvm::errs() << "Error: Variable-length arrays are not supported.\n";
            return nullptr;
        case TY_STRUCT:
        case TY_UNION: {
            std::vector<llvm::Type*> memberTypes;
            for (Member *mem = ty->members; mem; mem = mem->next) {
                llvm::Type *memberType = convertType(context, mem->ty);
                if (!memberType) {
                    llvm::errs() << "Error: Invalid member type.\n";
                    return nullptr;
                }
                memberTypes.push_back(memberType);
            }
            llvm::StringRef name = (ty->name && ty->name->str) ? llvm::StringRef(ty->name->str) : llvm::StringRef();
            return llvm::StructType::create(context, memberTypes, name);
        }
        default:
            llvm::errs() << "Error: Unsupported type kind.\n";
            return nullptr;
    }
}




llvm::Function* convertFunction(llvm::Module &module, llvm::LLVMContext &context, Obj *obj) {
    if (!obj->is_function) return nullptr;

    // Create function type
    llvm::Type *returnType = convertType(context, obj->ty);
    if (!returnType) {
        llvm::errs() << "Error: Invalid function return type.\n";
        return nullptr;
    }

    std::vector<llvm::Type*> paramTypes;
    for (Obj *param = obj->params; param; param = param->next) {
        llvm::Type *paramType = convertType(context, param->ty);
        if (!paramType) {
            llvm::errs() << "Error: Invalid parameter type.\n";
            return nullptr;
        }
        paramTypes.push_back(paramType);
    }

    llvm::FunctionType *funcType = llvm::FunctionType::get(returnType, paramTypes, obj->ty->is_variadic);
    llvm::Function *function = llvm::Function::Create(funcType, llvm::Function::ExternalLinkage, obj->name, module);

    // Create a basic block and set the builder to the start of the function
    llvm::BasicBlock *BB = llvm::BasicBlock::Create(context, "entry", function);
    llvm::IRBuilder<> builder(BB);

    // Allocate local variables
    for (Obj *local = obj->locals; local; local = local->next) {
        llvm::Type *localType = convertType(context, local->ty);
        if (localType) {
            builder.CreateAlloca(localType, nullptr, local->name);
        } else {
            llvm::errs() << "Error: Invalid local variable type.\n";
        }
    }

    return function;
}



// Convert `Obj` to LLVM Global Variable
llvm::GlobalVariable* convertGlobalVariable(llvm::Module &module, llvm::LLVMContext &context, Obj *obj) {
    llvm::Type *varType = convertType(context, obj->ty);
    if (!varType) {
        llvm::errs() << "Error: Unsupported global variable type: " << obj->name << "\n";
        return nullptr;
    }
    llvm::Constant *init = llvm::Constant::getNullValue(varType);
    return new llvm::GlobalVariable(module, varType, false, llvm::GlobalValue::ExternalLinkage, init, obj->name);
}

// Convert `Node` to LLVM Instruction (Placeholder)
llvm::Value* convertNode(llvm::IRBuilder<> &builder, Node *node) {
    if (!node) {
        llvm::errs() << "Error: Node is null.\n";
        return nullptr;
    }

    // Example of handling a condition node
    if (node->kind == ND_IF) {
        // Create LLVM IR for the condition
        llvm::Value *cond = builder.CreateICmpNE(builder.getInt1(0), builder.getInt1(1), "ifcond");
        // Create blocks for then and else
        llvm::Function *function = builder.GetInsertBlock()->getParent();
        llvm::BasicBlock *thenBB = llvm::BasicBlock::Create(builder.getContext(), "then", function);
        llvm::BasicBlock *elseBB = llvm::BasicBlock::Create(builder.getContext(), "else");
        llvm::BasicBlock *mergeBB = llvm::BasicBlock::Create(builder.getContext(), "ifcont");

        builder.CreateCondBr(cond, thenBB, elseBB);

        // Emit then block
        builder.SetInsertPoint(thenBB);
        builder.CreateBr(mergeBB);
 
        // Emit else block
        builder.SetInsertPoint(elseBB);
        builder.CreateBr(mergeBB);

        // Emit merge block
        builder.SetInsertPoint(mergeBB);
        return mergeBB;
    }

    return nullptr;
}


// Generate LLVM IR from Obj structure
void generateLLVMIR(Obj *prog, FILE *out) {
    llvm::LLVMContext context;
    llvm::Module module("ObjModule", context);
    llvm::IRBuilder<> builder(context);

    for (Obj *obj = prog; obj; obj = obj->next) {
        if (obj->is_function) {
            llvm::Function *function = convertFunction(module, context, obj);
            if (!function) {
                llvm::errs() << "Error converting function: " << obj->name << "\n";
                continue;
            }

            // Process function body
            if (obj->body) {
                llvm::BasicBlock *BB = llvm::BasicBlock::Create(context, "entry", function);
                builder.SetInsertPoint(BB);
                convertNode(builder, obj->body);
            }
        } else if (obj->is_local) {
            // Local variables should be handled inside the function context
            llvm::errs() << "Warning: Local variable at global scope: " << obj->name << "\n";
        } else {
            llvm::GlobalVariable *globalVar = convertGlobalVariable(module, context, obj);
            if (!globalVar) {
                llvm::errs() << "Error converting global variable: " << obj->name << "\n";
            }
        }
    }

    // Verify the module
    if (llvm::verifyModule(module, &llvm::errs())) {
        llvm::errs() << "Error: module verification failed\n";
        return;
    }

    // Print the IR to the provided FILE* out
    llvm::raw_fd_ostream llvmOut(fileno(out), false);
    module.print(llvmOut, nullptr);
}


/* int main() {
    // Example usage
    // Create an example Obj structure for testing
    chibiccType intType = { TY_INT, 4, 4 };
    Obj localVar = { nullptr, "localVar", nullptr, &intType, nullptr, true, 4, 0, 0, false, false, false, false, false, nullptr, nullptr, false, &localVar, nullptr, nullptr, nullptr, 0, false, false, {} };
    Obj function = { nullptr, "testFunction", "testFunction", &intType, nullptr, false, 4, 0, 0, true, true, false, false, false, nullptr, nullptr, false, &localVar, nullptr, nullptr, nullptr, 0, false, false, {} };

    FILE *out = fopen("output.ll", "w");
    generateLLVMIR(&function, out);
    fclose(out);

    return 0;
}
 */